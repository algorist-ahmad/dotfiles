############################
# Modify PS1 dynamically
############################

# Capture last exit status
LAST_EXIT=$?

# Define colors
GREEN='\[\033[0;32m\]'
RED='\[\033[0;31m\]'
BRIGHT_YELLOW='\[\033[1;33m\]'
MAGENTA='\[\033[0;35m\]'      # Magenta color for untracked files
CYAN='\[\033[0;36m\]'         # Cyan color for modified but unstaged
BLUE='\[\033[0;34m\]'         # Blue color for staged but uncommitted
RESET='\[\033[0m\]'           # Reset color to default

# Other
PROMPT_SYMBOL='$'

build_prompt() {
    # in the future, have unique symbol for general context
    symbol="\[$LAST_EXIT\]"
    # build time in HH:MM
    time="\[\e[92m\]$(date +'%H:%M')\[\e[0m\]"
    # build current path
    path="\[\033[01;34m\]\w\[\033[00m\]"
    # color the '$' symbol
    exit_indicator=$(build_exit_indicator)
    # get a report of the current repo, if there is one
    git_status_report=$(git_status_report)
    # Done! PS1 is ready
    PS1="$symbol $time $path $git_status_report $exit_indicator "
}

build_exit_indicator() {
    if [ $LAST_EXIT -eq 0 ]; then
        status="\[\[\e[1m\]$PROMPT_SYMBOL${RESET}\]"
    else
        status="\[${RED}\[\e[1m\]$PROMPT_SYMBOL${RESET}\]"
    fi

    echo $status
}


# Function to build Git status report
git_status_report() {
    if git rev-parse --is-inside-work-tree &>/dev/null; then
        local branch
        local ahead
        local behind
        local untracked
        local modified
        local staged
        local status=""

        # Get current branch name
        branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "unknown-branch")

        # Check for different types of changes
        untracked=$(git status --porcelain | grep '^??' | wc -l)
        modified=$(git status --porcelain | grep '^[ MAD]' | grep -v '^\s*M' | wc -l)
        staged=$(git status --porcelain | grep '^[ AM]' | grep -v '^\s*M' | wc -l)

        # Get the number of commits ahead and behind the upstream branch
        ahead=$(git rev-list --count HEAD ^@{upstream} 2>/dev/null || echo 0)
        behind=$(git rev-list --count @{upstream} ^HEAD 2>/dev/null || echo 0)

        # Build status message based on changes
        if [ "$untracked" -gt 0 ]; then
            status+="\[$MAGENTA\]⊕${untracked}\[$RESET\] "
        fi

        if [ "$modified" -gt 0 ]; then
            status+="\[$CYAN\]✎${modified}\[$RESET\] "
        fi

        if [ "$staged" -gt 0 ]; then
            status+="\[$BLUE\]✏${staged}\[$RESET\] "
        fi

        if [ "$untracked" -gt 0 ] || [ "$modified" -gt 0 ] || [ "$staged" -gt 0 ]; then
            status+="\[$RED\]●\[$RESET\] $branch"
        else
            status+="\[$GREEN\]✓\[$RESET\] $branch"
        fi

        if [ "$ahead" -gt 0 ] || [ "$behind" -gt 0 ]; then
            status+=" \[$BRIGHT_YELLOW\](${ahead}↑${behind}↓)\[$RESET\]"
        fi

        echo "$status"
    fi
}

build_prompt
